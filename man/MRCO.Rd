% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MRCO.R
\name{MRCO}
\alias{MRCO}
\title{Multi Resolution Cluster Optimization}
\usage{
MRCO(
  metadata = NULL,
  metadata_column_name = NULL,
  clustering_columns = NULL,
  nbins = 4,
  suggest_cut = TRUE,
  edge_num_size_filter = 0,
  edge_prop_size_filter = 0.05,
  nodes_selection = NULL,
  merge_downwards = FALSE,
  plot = TRUE,
  no_labels = FALSE,
  highlight_selection = TRUE,
  silent = FALSE,
  igraph_layout_type = "tree",
  edge_ratio_weigth = 0.9
)
}
\arguments{
\item{metadata}{data.frame or tibble: with row names (cell ids) and
column names (cell metadata variables)}

\item{metadata_column_name}{character or unquoted name: name the metadata
column to plot piechart nodes from}

\item{clustering_columns}{character prefix or tidy-select: to distinguish
clustering resolution columns from metadata columns.}

\item{nbins}{numeric, set the number of bins to create from given metadata
column if it is numeric data}

\item{suggest_cut}{logical, TRUE to suggest stable nodes based on graph
structure, FALSE to skip automated selection}

\item{edge_num_size_filter}{numeric, give the minimum number of samples
required to draw an edge}

\item{edge_prop_size_filter}{numeric, give the minimum edge ratio, which is
displaying the proportion of samples that move between nodes to draw an edge}

\item{nodes_selection}{character vector or list, two ways to manually select
a node by its global id from the graph}

\item{merge_downwards}{logical, cells which are in multiple selected clusters
 can either be assorted into the first or last cluster available for them.
FALSE means that clusters are merged from the bottom towards the top of
 the graph, hence cells which are part of a higher resolution cluster will
  remain in it.
TRUE means that clusters are merged from top towards the bottom, hence cells
 will end up in the lowest resolution cluster that they may end in.}

\item{plot}{logical, FALSE to skip plotting}

\item{no_labels}{logical, TRUE to turn off cluster labels}

\item{highlight_selection}{logical, TRUE to highlight selected nodes}

\item{silent}{logical, TRUE to suppress messages}

\item{igraph_layout_type}{character giving the igraph layout type for graph creation; either "tree" or "sugiyama"}

\item{edge_ratio_weigth}{numeric between 0 and 1, when stable edges are determined their edge ratio must be larger than the branch paths maximum edge ratio timed edge_ratio_weight.
Therefore, a value closer to 1 is less permissive towards noise, whereas a value closer to 0 may handle noisier graphs better.}
}
\value{
list, contains the graph layout. May contain selected nodes, the resulting clustering and the ggplot object if respective functions are used.
}
\description{
MRCO visualizes the results of a clustering algorithm across different
 resolutions (sensitivities) in a treelike graph.
 This graph can display differences in sample compositions and give an
 intuitive solution to choosing the best amount of clusters for your
 experiment. \cr
Simply run your clustering algorithm of choice multiple
 times across a sensitivity range of interest. MRCO takes these clustering
 results as input, compares them, finds stable clusters that represent
 the data across your range of resolution, and returns the new clustering.\cr
MRCO can also plot clusters as pie chart nodes to visualize the composition.
 This can help distinguish which metadata variable correlates with
 cluster separation across increasing sensitivity.
}
\examples{
if (requireNamespace("utils")){
    library(MRCO)
    data(example_data)

    #Plot Clusters as Treelike Graph. Use the prefix to select clustering columns.
    MRCO(example_data, clustering_columns = "0.")
    # Piechart plot both discrete ...
    MRCO(example_data, metadata_column_name = "quality",
         clustering_columns = "0.")
    # ... and continuous sample level metadata.
    MRCO(example_data, "expr_A", clustering_columns = "0.")
    # Select your clusters manually at wish.
    # Each node is pasted by its resolution step (Y axis) and its cluster NR.
    # The top node is called 0_1, the bottom leafs are 4_1, 4_2, 4_3, 4_0 etc.
    # Either select by named list or character vector.
    MRCO(example_data, "batch", clustering_columns = "0.",
         nodes_selection=list("3"=c(1, 0),
                              "4"=c(2, 3)))
    MRCO_res <- MRCO(example_data, clustering_columns = "0.",
                     nodes_selection=c("2_0","4_3"))

    # Find the selection & adjust it at wish.
    MRCO_res$selected_nodes
    #Any sample not selected end up in a 'debris' cluster
    head(MRCO_res$MRCO_clustering)
}
}
