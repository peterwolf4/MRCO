% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_input_checker.R
\name{input_checker_MRCO}
\alias{input_checker_MRCO}
\title{Input checker MRCO}
\usage{
input_checker_MRCO(
  metadata = NULL,
  metadata_column_name = NULL,
  prefix = NULL,
  suffix = NULL,
  metadata_column_nbins = NULL,
  plot_col_gradient = NULL,
  suggest_cut = NULL,
  reduce_branchlist = NULL,
  edge_num_size_filter = NULL,
  edge_prop_size_filter = NULL,
  nodes_selection = NULL,
  merge_downwards = NULL,
  plot = NULL,
  no_labels = NULL,
  silent = NULL,
  warnings = NULL,
  highlight_selection = NULL
)
}
\arguments{
\item{metadata}{data.frame or tibble with dim-names: row names cell identities and column names cell level metadata variables}

\item{metadata_column_name}{character or tidy-selection style unquoted name of a metadata column to plot piechart nodes from}

\item{prefix}{character, prefix of metadata columns which contain the increments of resolution}

\item{suffix}{character, suffix of metadata columns which contain the increments of resolution}

\item{metadata_column_nbins}{NULL, "all" or a numeric, set the number of bins to create from given metadata column if it is continuous data}

\item{plot_col_gradient}{NULL for auto detect, or logical, TRUE to use continuous fill, FALSE for discrete fill; only applies when continuous metadata column is selected}

\item{suggest_cut}{logical, TRUE to suggest stable nodes based on graph structure, FALSE to skip}

\item{reduce_branchlist}{logical, TRUE to walk as few paths as possible while still visiting every node, FALSE to walk any possible path passing the edge_filters; warning memory expensive, adjust branches_overflow parameter! Only relevant if suggest_cut is TRUE.}

\item{edge_num_size_filter}{numeric, give the number of cells that must be surpassed to draw edge, has to be set for each data set as its highly dependent on nr of cells within data}

\item{edge_prop_size_filter}{numeric, give the proportion of cells that must move between nodes to draw edge}

\item{nodes_selection}{vector or list, two ways to manually select a node by its global id from the graph:
either give resolution step and cluster id from that resolution as underscore separated character string,
 or give a list named where each name corresponds to a resolution step and its element is a single vector containing the cluster ids that are to be selected of that resolution.}

\item{merge_downwards}{logical, cells which are in multiple selected clusters can either be assorted into the first or last cluster available for them.
FALSE means that clusters are merged from the bottom towards the top of the graph, hence cells which are part of a higher resolution cluster will remain in it.
TRUE means that clusters are merged from top towards the bottom, hence cells will end up in the lowest resolution cluster that they may end in.}

\item{plot}{logical, FALSE to skip plotting}

\item{no_labels}{logical, TRUE to turn off cluster labels, FALSE default for labeled clusters}

\item{silent}{logical, FALSE to suppress messages and warnings}

\item{warnings}{logical, set to FALSE if warnings should not be printed to console.}

\item{highlight_selection}{logical, TRUE to highlight selected nodes}

\item{cellnames_column_name}{Optional NULL, character or name of a column containing ceell names in metadata}

\item{count_matrix}{UPDATE sparseMatrix or other matrix forms, UPDATE which exactly, containing the counts used for cluster_Scatter calculation}

\item{cluster_scatter_matrix}{UPDATE sparseMatrix or other matrix forms, UPDATE which exactly, containing calculated cluster scatter for each cluster found in metadata}
}
\description{
Input checker MRCO
}
